<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The Ocean Code on The Ocean Code</title>
    <link>https://theoceancode.netlify.app/</link>
    <description>Recent content in The Ocean Code on The Ocean Code</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-uk</language>
    <copyright>&amp;copy; 2019</copyright>
    <lastBuildDate>Tue, 22 Aug 2023 00:00:00 +0200</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A dataset for investigating socio-ecological changes in Arctic fjords</title>
      <link>https://theoceancode.netlify.app/publication/drivers_data/</link>
      <pubDate>Tue, 22 Aug 2023 00:00:00 +0200</pubDate>
      
      <guid>https://theoceancode.netlify.app/publication/drivers_data/</guid>
      <description></description>
    </item>
    
    <item>
      <title>heatwave3</title>
      <link>https://theoceancode.netlify.app/package/heatwave3/</link>
      <pubDate>Thu, 10 Aug 2023 00:00:00 +0200</pubDate>
      
      <guid>https://theoceancode.netlify.app/package/heatwave3/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Basic detection and categorisation of events</title>
      <link>https://theoceancode.netlify.app/talk/clivar_2023/</link>
      <pubDate>Mon, 24 Jul 2023 00:00:00 +0200</pubDate>
      
      <guid>https://theoceancode.netlify.app/talk/clivar_2023/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Drivers of change in Arctic fjord socio-ecological systems: Examples from the European Arctic</title>
      <link>https://theoceancode.netlify.app/publication/drivers_arctic/</link>
      <pubDate>Thu, 05 Jan 2023 00:00:00 +0100</pubDate>
      
      <guid>https://theoceancode.netlify.app/publication/drivers_arctic/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Marine heatwaves drive recurrent mass mortalities in the Mediterranean Sea</title>
      <link>https://theoceancode.netlify.app/publication/med_mass/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0200</pubDate>
      
      <guid>https://theoceancode.netlify.app/publication/med_mass/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Sea Ice and Substratum Shape Extensive Kelp Forests in the Canadian Arctic</title>
      <link>https://theoceancode.netlify.app/publication/sea_ice_kelp/</link>
      <pubDate>Thu, 31 Mar 2022 00:00:00 +0200</pubDate>
      
      <guid>https://theoceancode.netlify.app/publication/sea_ice_kelp/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Kelp in the Eastern Canadian Arctic: Current and Future Predictions of Habitat Suitability and Cover</title>
      <link>https://theoceancode.netlify.app/publication/eastern_arctic/</link>
      <pubDate>Thu, 07 Oct 2021 00:00:00 +0200</pubDate>
      
      <guid>https://theoceancode.netlify.app/publication/eastern_arctic/</guid>
      <description></description>
    </item>
    
    <item>
      <title>A novel approach to quantify metrics of upwelling intensity, frequency, and duration</title>
      <link>https://theoceancode.netlify.app/publication/upwelling_definition/</link>
      <pubDate>Thu, 08 Jul 2021 00:00:00 +0200</pubDate>
      
      <guid>https://theoceancode.netlify.app/publication/upwelling_definition/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ODV figures in R with bathymetry</title>
      <link>https://theoceancode.netlify.app/post/odv_bathy/</link>
      <pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://theoceancode.netlify.app/post/odv_bathy/</guid>
      <description>

&lt;h2 id=&#34;objective&#34;&gt;Objective&lt;/h2&gt;

&lt;p&gt;Nearly four years after writing a blog post about &lt;a href=&#34;https://theoceancode.netlify.app/post/odv_figures/&#34; target=&#34;_blank&#34;&gt;recreating R figures in ODV&lt;/a&gt; I had someone reach out to me expressing interest in adding a bathymetry layer over the interpolated data. It&amp;rsquo;s always nice to know that these blog posts are being found useful for other researchers. And I have to admit I&amp;rsquo;m a bit surprised that the code still runs 4 years later. Especially considering that it uses the &lt;strong&gt;&lt;code&gt;tidyverse&lt;/code&gt;&lt;/strong&gt; which is notorious for breaking backwards compatibility. In order to demonstrate the overlaying of bathymetry data on a CTD transect we will need to use a different dataset than in the previous blog post. One may use any data one would like, but for this blog I went to this &lt;a href=&#34;https://robert-schlegel.shinyapps.io/CTD_project/&#34; target=&#34;_blank&#34;&gt;shiny app&lt;/a&gt; to extract some data from the coast of South Africa. Specifically I filtered for temperature data from November 1990 at all depths. We won&amp;rsquo;t go back over the theory for recreating the ODV figure in this blog post, so please revisit that for a recap as necessary. Below I will show two of the necessary steps to get interpolated CTD data before we begin on the bathymetry mask.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Load libraries
library(tidyverse)
library(lubridate)
library(reshape2)
library(MBA)
library(mgcv)
library(marmap)
library(FNN)

# The transects in this dataset do not have an ID column
# So we manually select the first transect (rows 1 - 12)
# This is then used as a mask to select all depths for these pixels
# We will also use these unique lon/lat coords for bathymetry points
ctd_mask &amp;lt;- read_csv(&amp;quot;../../static/data/CTD_transect.csv&amp;quot;) %&amp;gt;% 
  select(lon, lat) %&amp;gt;% 
  slice(1:12) %&amp;gt;% 
  unique()

# Load and screen data
  # For ease I am only using monthly means
  # and depth values rounded to 10 metres
ctd &amp;lt;- read_csv(&amp;quot;../../static/data/CTD_transect.csv&amp;quot;) %&amp;gt;% 
  mutate(depth = -depth) %&amp;gt;%  # Correct for plotting
  right_join(ctd_mask, by = c(&amp;quot;lon&amp;quot;, &amp;quot;lat&amp;quot;)) %&amp;gt;% 
  select(lon, lat, depth, temp)

# Manually extracted hexidecimal ODV colour palette
ODV_colours &amp;lt;- c(&amp;quot;#feb483&amp;quot;, &amp;quot;#d31f2a&amp;quot;, &amp;quot;#ffc000&amp;quot;, &amp;quot;#27ab19&amp;quot;, &amp;quot;#0db5e6&amp;quot;, &amp;quot;#7139fe&amp;quot;, &amp;quot;#d16cfa&amp;quot;)

# Create quick scatterplot
ggplot(data = ctd, aes(x = lon, y = depth)) +
  geom_point(aes(colour = temp)) +
  scale_colour_gradientn(colours = rev(ODV_colours)) +
  labs(y = &amp;quot;depth (m)&amp;quot;, x = &amp;quot;longitude (°E)&amp;quot;, colour = &amp;quot;temp. (°C)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://theoceancode.netlify.app/post/odv_bathy_files/figure-html/setup-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 1&lt;/strong&gt;: A non-interpolated scatterplot of our temperature (°C) data shown as a function of depth (m) over longitude (°E).&lt;/p&gt;

&lt;p&gt;It looks like we have a nice little upwelling signal coming through at the coast. It will be interesting to see how the interpolation handles that. We&amp;rsquo;ll quickly run the interpolation and then get to the bathymetry overlay. Note that these data are not on a straight latitude transect, but we are not going to worry about that in this blog post.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Now we may interpolate the data
# NB: The columns that mba.surf() will interpolate are the X, Y, Z values in that order
ctd_mba &amp;lt;- mba.surf(ctd[c(&amp;quot;lon&amp;quot;, &amp;quot;depth&amp;quot;, &amp;quot;temp&amp;quot;)], no.X = 300, no.Y = 300, extend = T)
dimnames(ctd_mba$xyz.est$z) &amp;lt;- list(ctd_mba$xyz.est$x, ctd_mba$xyz.est$y)
ctd_mba &amp;lt;- melt(ctd_mba$xyz.est$z, varnames = c(&#39;lon&#39;, &#39;depth&#39;), value.name = &#39;temp&#39;) %&amp;gt;% 
  filter(depth &amp;lt; 0) %&amp;gt;% 
  mutate(temp = round(temp, 1))

# Finally we create our gridded result
ggplot(data = ctd_mba, aes(x = lon, y = depth)) +
  geom_raster(aes(fill = temp)) +
  geom_contour(aes(z = temp), binwidth = 2, colour = &amp;quot;black&amp;quot;, alpha = 0.2) +
  geom_contour(aes(z = temp), breaks = 20, colour = &amp;quot;black&amp;quot;) +
  scale_fill_gradientn(colours = rev(ODV_colours)) +
  labs(y = &amp;quot;depth (m)&amp;quot;, x = &amp;quot;longitude (°E)&amp;quot;, fill = &amp;quot;temp. (°C)&amp;quot;) +
  coord_cartesian(expand = F)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://theoceancode.netlify.app/post/odv_bathy_files/figure-html/interp-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 2&lt;/strong&gt;: The same temperature (°C) profiles seen in Figure 1 with the missing values filled in with multilevel B-splines.&lt;/p&gt;

&lt;h2 id=&#34;bathymetry&#34;&gt;Bathymetry&lt;/h2&gt;

&lt;p&gt;The interpolation seems to have done a decent job of acknowledging the upwelling signal. It may be possible to tweak the interpolation more, as desired, but I&amp;rsquo;m happy enough with it for the purposes of this post. We are going to skip over the step to cut out the artefacts at the bottom of the figure where there are not data points because we are rather going to just overlay our bathymetry mask. First we will download the bathymetry data. Then we find the points that are closest to our CTD transect. These will then be used for the grey overlay at the bottom of the figure.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Bathymetry within transect bounding box
bathy &amp;lt;- getNOAA.bathy(lon1 = min(ctd$lon), lon2 = max(ctd$lon), 
                       lat1 = min(ctd$lat), lat2 = max(ctd$lat), 
                       resolution = 5) # Larger numbers for coarser data

# Convert bathy object to a data.frame for easier use
bathy_df &amp;lt;- data.frame(lon_b = as.numeric(rownames(bathy)),
                       lat_b = as.numeric(colnames(bathy)),
                       depth = as.numeric(bathy)) %&amp;gt;% 
  mutate(bathy_idx = 1:n()) # Used for merging CTD and bathy data

# Find nearest points to transect data
ctd_mask &amp;lt;- ctd_mask %&amp;gt;% 
  mutate(bathy_idx = as.vector(knnx.index(as.matrix(bathy_df[,c(&amp;quot;lon_b&amp;quot;, &amp;quot;lat_b&amp;quot;)]),
                                           as.matrix(ctd_mask[,c(&amp;quot;lon&amp;quot;, &amp;quot;lat&amp;quot;)]), k = 1))) %&amp;gt;% 
  left_join(bathy_df, by = &amp;quot;bathy_idx&amp;quot;)

# Manually create bottom of the bathy mask polygon
bathy_mask &amp;lt;- data.frame(lon = c(ctd_mask$lon, rev(ctd_mask$lon)),
                         depth = c(ctd_mask$depth, rep(min(ctd_mask$depth), nrow(ctd_mask))))

# We may now use that bathy mask for our final figure
ggplot(data = ctd_mba, aes(x = lon, y = depth)) +
  geom_raster(aes(fill = temp)) +
  geom_contour(aes(z = temp), binwidth = 2, colour = &amp;quot;black&amp;quot;, alpha = 0.2) +
  geom_contour(aes(z = temp), breaks = 20, colour = &amp;quot;black&amp;quot;) +
  geom_polygon(data = bathy_mask, fill = &amp;quot;grey80&amp;quot;, colour = &amp;quot;black&amp;quot;) +
  scale_fill_gradientn(colours = rev(ODV_colours)) +
  labs(y = &amp;quot;depth (m)&amp;quot;, x = &amp;quot;longitude (°E)&amp;quot;, fill = &amp;quot;temp. (°C)&amp;quot;) +
  coord_cartesian(expand = F)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://theoceancode.netlify.app/post/odv_bathy_files/figure-html/bathy-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 3&lt;/strong&gt;: The same temperature (°C) profiles seen in Figure 2 with the bathymetry values overlaid.&lt;/p&gt;

&lt;p&gt;Unfortunately in this example there is a bit of blank space in the bottom left of the plot because the CTD casts do not go deeper than 200 m, and the interpolation doesn&amp;rsquo;t fill in values outside of the rectangular box dictated by the X (lon) and Y (depth) values. A cheeky workaround for this issue would be to simply crop the figure to the bottom of the interpolated data, and not the bathymetry.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# We may now use that bathy mask for our final figure
ggplot(data = ctd_mba, aes(x = lon, y = depth)) +
  geom_raster(aes(fill = temp)) +
  geom_contour(aes(z = temp), binwidth = 2, colour = &amp;quot;black&amp;quot;, alpha = 0.2) +
  geom_contour(aes(z = temp), breaks = 20, colour = &amp;quot;black&amp;quot;) +
  geom_polygon(data = bathy_mask, fill = &amp;quot;grey80&amp;quot;, colour = &amp;quot;black&amp;quot;) +
  geom_point(data = ctd, aes(x = lon, y = depth),
             colour = &#39;black&#39;, size = 0.2, alpha = 0.4, shape = 8) +
  scale_fill_gradientn(colours = rev(ODV_colours)) +
  labs(y = &amp;quot;depth (m)&amp;quot;, x = &amp;quot;longitude (°E)&amp;quot;, fill = &amp;quot;temp. (°C)&amp;quot;) +
  coord_cartesian(expand = F, ylim = c(-200, 0)) +
  theme(panel.border = element_rect(fill = NA, colour = &amp;quot;black&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://theoceancode.netlify.app/post/odv_bathy_files/figure-html/bathy-crop-1.png&#34; width=&#34;672&#34; /&gt;
&lt;strong&gt;Figure 4&lt;/strong&gt;: The plotting area cropped to the interpolated data, rather than the bathymetry mask. Also shown with black dots are the original CTD data.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this tutorial we have seen how to plot a bathymetry overlay that matches the lon/lat coordinates of the CTD casts. I&amp;rsquo;m sure there is a way to force the interpolation to fill in values at a greater depth to match the bathymetry, but the focus of this blog was on adding the bathymetry mask itself, and I think we have addressed this issue. The workflow outlined above has a couple of bumps in it, but should be adaptable to a range of applications.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Drivers of Marine Heatwaves in the Northwest Atlantic: The Role of Air–Sea Interaction During Onset and Decline</title>
      <link>https://theoceancode.netlify.app/publication/primary_drivers/</link>
      <pubDate>Tue, 09 Mar 2021 00:00:00 +0100</pubDate>
      
      <guid>https://theoceancode.netlify.app/publication/primary_drivers/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Variation and Change of Upwelling Dynamics Detected in the World’s Eastern Boundary Upwelling Systems</title>
      <link>https://theoceancode.netlify.app/publication/upwelling_detection/</link>
      <pubDate>Wed, 03 Feb 2021 00:00:00 +0100</pubDate>
      
      <guid>https://theoceancode.netlify.app/publication/upwelling_detection/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Marine Heatwaves</title>
      <link>https://theoceancode.netlify.app/publication/mhw/</link>
      <pubDate>Sun, 03 Jan 2021 00:00:00 +0100</pubDate>
      
      <guid>https://theoceancode.netlify.app/publication/mhw/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Marine cold-spells</title>
      <link>https://theoceancode.netlify.app/publication/mcs/</link>
      <pubDate>Sun, 03 Jan 2021 00:00:00 +0100</pubDate>
      
      <guid>https://theoceancode.netlify.app/publication/mcs/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Analysis of Bio-Oracle data</title>
      <link>https://theoceancode.netlify.app/post/bo_analysis/</link>
      <pubDate>Thu, 18 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://theoceancode.netlify.app/post/bo_analysis/</guid>
      <description>

&lt;h2 id=&#34;objective&#34;&gt;Objective&lt;/h2&gt;

&lt;p&gt;While running some brief quality control tests on Bio-Oracle layers before using them for a recent project it was detected that some of the layers in the current version of the Bio-Oracle product appear to have very large errors. Specifically the error is that there are layers where the minimum values are greater than the maximum values. It is unclear how this could be possible, so in the following text and code we will look into how we go about investigating these data layers and we will discuss which layers are fine, and which are not. This error was first detected in the current velocity layers but a brief search turned up errors in other layers, too. So in this post we will be going through each individual layer to test for this max less than min error. We will look at all of the different depths as well as the future projections.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Load required libraries
library(tidyverse)
library(sdmpredictors)

# The possible layers for download from Bio-Oracle
BO_layers &amp;lt;- list_layers(datasets = &amp;quot;Bio-ORACLE&amp;quot;)

# The future layers
BO_layers_future &amp;lt;- list_layers_future(datasets = &amp;quot;Bio-ORACLE&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;testing-pipeline&#34;&gt;Testing pipeline&lt;/h2&gt;

&lt;p&gt;The following code chunk contains a function that will run the testing pipeline that highlights any errors in the data. To use it we choose a variable from the list of Bio-Oracle variables shown above that have a max and min version of the layer. One must replace the &amp;lsquo;max&amp;rsquo; or &amp;lsquo;min&amp;rsquo; with &amp;lsquo;X&amp;rsquo; and give that to the function, it will do the rest. Note that if one is running this script the figures this function will save to disk take about 1 minute to render due to their high resolution. Also please note that this function assumes there is a &amp;ldquo;figures&amp;rdquo; folder in the root directory on the computer on which this code is being run. If not, one must be created or the function must be changed to point to the desired folder.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;BO_test &amp;lt;- function(var_name, scenario = &amp;quot;present&amp;quot;, year = NA){
  
  # Establish min/max layer names
  min_layer &amp;lt;- gsub(&amp;quot;X&amp;quot;, &amp;quot;min&amp;quot;, var_name)
  max_layer &amp;lt;- gsub(&amp;quot;X&amp;quot;, &amp;quot;max&amp;quot;, var_name)
  
  # Download data
  if(scenario == &amp;quot;present&amp;quot;){
    BO_layers_dl &amp;lt;- load_layers(c(min_layer, max_layer))
    var_title &amp;lt;- var_name
  } else {
    BO_layer_names &amp;lt;- get_future_layers(c(min_layer, max_layer), scenario = scenario, year = year)
    BO_layers_dl &amp;lt;- load_layers(BO_layer_names$layer_code)
    var_title &amp;lt;- gsub(&amp;quot;max_&amp;quot;, &amp;quot;X_&amp;quot;, BO_layer_names$layer_code[1])
  }
  
  # Prepare data for plotting
  BO_layers_test &amp;lt;- as.data.frame(BO_layers_dl, xy = T) %&amp;gt;% 
    dplyr::rename(lon = x, lat = y) %&amp;gt;% 
    mutate(lon = round(lon, 4), 
           lat = round(lat, 4)) %&amp;gt;% 
    na.omit() %&amp;gt;% 
    `colnames&amp;lt;-`(c(&amp;quot;lon&amp;quot;, &amp;quot;lat&amp;quot;, &amp;quot;min_val&amp;quot;, &amp;quot;max_val&amp;quot;)) %&amp;gt;% 
    mutate(max_min = ifelse(max_val &amp;gt;= min_val, TRUE, FALSE))
  
  # Visualise pixels where min values are greater than the max
  test_plot &amp;lt;- ggplot(data = BO_layers_test, aes(x = lon, y = lat)) +
    geom_raster(aes(fill = max_min)) +
    coord_quickmap(expand = F) +
    labs(fill = &amp;quot;Max greater than min&amp;quot;, x = NULL, y = NULL, title = var_title) +
    theme(legend.position = &amp;quot;bottom&amp;quot;)
  
  # Save figure to disk
  ggsave(paste0(&amp;quot;~/figures/&amp;quot;,var_title,&amp;quot;.png&amp;quot;), test_plot, height = 5, width = 8)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;look-at-layers&#34;&gt;Look at layers&lt;/h2&gt;

&lt;p&gt;In this section we will go through all of the BO layers that have a min/max option and we will compare them to ascertain whether the maximum values are always greater than the minimums, which they should be, but we have found that sometimes this is not the case. When possible we will also look at future projections of the layers with RCP8.5 at 2050 and 2100. In the first code chunk in this section we will look at the older Bio-Oracle layers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Up first we start with the older Bio-Oracle layers

# Bathymetry
BO_test(&amp;quot;BO_bathyX&amp;quot;) # No issues

# Chlorophyll
BO_test(&amp;quot;BO_chloX&amp;quot;) # No issues

# Cloud fraction
BO_test(&amp;quot;BO_cloudX&amp;quot;) # No issues

# Diffuse attenuation
BO_test(&amp;quot;BO_daX&amp;quot;) # No issues

# SST
BO_test(&amp;quot;BO_sstX&amp;quot;) # No issues
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is reassuring to see that all of the older BO layers have no issues in them. From my initial testing it looked like the layers with errors may have been from data assimilation from the GLORYS product for the most recent Bio-Oracle layers. That the older layers have no issues appears to support the hypothesis that the bug in the Bio-Oracle pipeline was introduced in the BO2 version of the product.&lt;/p&gt;

&lt;p&gt;The next code chunk goes through all of the newer layers and where possible the future projections, too. Note that many layers have four different depth options. The surface (ss), the min (bdmin), the mean (bdmean), and the max (bdmax) depths present at each pixel. We are testing all of these as I have hypothesised that the inclusion of these three different depths may be responsible for some of the errors observed. Another distinction to make for the following tests is that there are min/max values for each layer, which take the absolute min/max recorded at a pixel. And then there are the long-term min/max values, which are the average annual min/max recorded over the length of the available data. The long-term min/max values are more representative of the climatological means within an area, and the absolute min/max are representative of the most extreme events that may occur in an area. Generally one is going to be more interested in the long-term values for normal species distribution modelling (SDM) applications. Because these min/max values are calculated differently it is necessary to test both of them to see if the errors in the data differ in any discernible way.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Carbon phytoplankton biomass absolute
BO_test(&amp;quot;BO2_carbonphytoX_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_carbonphytoX_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_carbonphytoX_bdmin&amp;quot;) # No issues
BO_test(&amp;quot;BO2_carbonphytoX_ss&amp;quot;) # No issues

# Carbon phytoplankton biomass long-term
BO_test(&amp;quot;BO2_carbonphytoltX_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_carbonphytoltX_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_carbonphytoltX_bdmin&amp;quot;) # No issues
BO_test(&amp;quot;BO2_carbonphytoltX_ss&amp;quot;) # No issues

# Chlorophyll absolute
BO_test(&amp;quot;BO2_chloX_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_chloX_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_chloX_bdmin&amp;quot;) # No issues
BO_test(&amp;quot;BO2_chloX_ss&amp;quot;) # No issues
BO_test(&amp;quot;BO2_chloX_ss&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Most pixels fail
BO_test(&amp;quot;BO2_chloX_ss&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Slightly better than the 2050 data

# Chlorophyll long-term
BO_test(&amp;quot;BO2_chloltX_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_chloltX_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_chloltX_bdmin&amp;quot;) # No issues
BO_test(&amp;quot;BO2_chloltX_ss&amp;quot;) # No issues
BO_test(&amp;quot;BO2_chloltX_ss&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Same issues as absolute layer
BO_test(&amp;quot;BO2_chloltX_ss&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Slightly better than the 2050 data

# Current velocities absolute
BO_test(&amp;quot;BO2_curvelX_bdmax&amp;quot;) # Global issues
BO_test(&amp;quot;BO2_curvelX_bdmax&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Global issues
BO_test(&amp;quot;BO2_curvelX_bdmax&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Global issues
BO_test(&amp;quot;BO2_curvelX_bdmean&amp;quot;) # Global issues
BO_test(&amp;quot;BO2_curvelX_bdmean&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Global issues
BO_test(&amp;quot;BO2_curvelX_bdmean&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Global issues
BO_test(&amp;quot;BO2_curvelX_bdmin&amp;quot;) # Global issues
BO_test(&amp;quot;BO2_curvelX_bdmin&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Global issues
BO_test(&amp;quot;BO2_curvelX_bdmin&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Global issues
BO_test(&amp;quot;BO2_curvelX_ss&amp;quot;) # Mostly fails around the equator
BO_test(&amp;quot;BO2_curvelX_ss&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Mirror image errors of present day
BO_test(&amp;quot;BO2_curvelX_ss&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Mirror image errors of present day

# Current velocities long-term
# The first issue noted in the BO2 layers were these
BO_test(&amp;quot;BO2_curvelltX_bdmax&amp;quot;) # Global issues
BO_test(&amp;quot;BO2_curvelltX_bdmax&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Global issues
BO_test(&amp;quot;BO2_curvelltX_bdmax&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Global issues
BO_test(&amp;quot;BO2_curvelltX_bdmean&amp;quot;) # Global issues
BO_test(&amp;quot;BO2_curvelltX_bdmean&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Global issues
BO_test(&amp;quot;BO2_curvelltX_bdmean&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Global issues
BO_test(&amp;quot;BO2_curvelltX_bdmin&amp;quot;) # Global issues
BO_test(&amp;quot;BO2_curvelltX_bdmin&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Global issues
BO_test(&amp;quot;BO2_curvelltX_bdmin&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Global issues
BO_test(&amp;quot;BO2_curvelltX_ss&amp;quot;) # Mostly fails around the equator
BO_test(&amp;quot;BO2_curvelltX_ss&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Mirror image errors of present day
BO_test(&amp;quot;BO2_curvelltX_ss&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Mirror image errors of present day

# Dissolved oxygen
BO_test(&amp;quot;BO2_dissoxX_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_dissoxX_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_dissoxX_bdmin&amp;quot;) # No issues
BO_test(&amp;quot;BO2_dissoxX_ss&amp;quot;) # No issues

# Dissolved oxygen long-term
BO_test(&amp;quot;BO2_dissoxltX_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_dissoxltX_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_dissoxltX_bdmin&amp;quot;) # No issues
BO_test(&amp;quot;BO2_dissoxltX_ss&amp;quot;) # No issues

# Ice cover
BO_test(&amp;quot;BO2_icecoverX_ss&amp;quot;) # No issues

# Ice cover long-term
BO_test(&amp;quot;BO2_icecoverltX_ss&amp;quot;) # No issues

# Ice thickness
BO_test(&amp;quot;BO2_icethickX_ss&amp;quot;) # No issues
BO_test(&amp;quot;BO2_icethickX_ss&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # All ice layers areas appear to be wrong
BO_test(&amp;quot;BO2_icethickX_ss&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # All ice layers areas appear to be wrong

# Ice thickness long-term
BO_test(&amp;quot;BO2_icethickltX_ss&amp;quot;) # No issues
BO_test(&amp;quot;BO2_icethickltX_ss&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # All ice layers areas appear to be wrong
BO_test(&amp;quot;BO2_icethickltX_ss&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # All ice layers areas appear to be wrong

# Iron
BO_test(&amp;quot;BO2_ironX_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_ironX_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_ironX_bdmin&amp;quot;) # No issues
BO_test(&amp;quot;BO2_ironX_ss&amp;quot;) # No issues

# Iron long-term
BO_test(&amp;quot;BO2_ironltX_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_ironltX_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_ironltX_bdmin&amp;quot;) # No issues
BO_test(&amp;quot;BO2_ironltX_ss&amp;quot;) # No issues

# Light at bottom
BO_test(&amp;quot;BO2_lightbotX_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_lightbotX_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_lightbotX_bdmin&amp;quot;) # No issues

# Light at bottom long-term
BO_test(&amp;quot;BO2_lightbotltX_bdmax&amp;quot;) # Global errors different from current velocity errors
BO_test(&amp;quot;BO2_lightbotltX_bdmean&amp;quot;) # Global errors different from current velocity errors
BO_test(&amp;quot;BO2_lightbotltX_bdmin&amp;quot;) # Global errors different from current velocity errors

# Nitrate
BO_test(&amp;quot;BO2_nitratemax_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_nitratemax_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_nitratemax_bdmin&amp;quot;) # No issues
BO_test(&amp;quot;BO2_nitratemax_ss&amp;quot;) # No issues

# Nitrate long-term
BO_test(&amp;quot;BO2_nitrateltmax_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_nitrateltmax_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_nitrateltmax_bdmin&amp;quot;) # No issues
BO_test(&amp;quot;BO2_nitrateltmax_ss&amp;quot;) # No issues

# Phosphate absolute
BO_test(&amp;quot;BO2_phosphateX_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_phosphateX_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_phosphateX_bdmin&amp;quot;) # No issues
BO_test(&amp;quot;BO2_phosphateX_ss&amp;quot;) # No issues

# Phosphate long-term
BO_test(&amp;quot;BO2_phosphateltX_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_phosphateltX_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_phosphateltX_bdmin&amp;quot;) # No issues
BO_test(&amp;quot;BO2_phosphateltX_ss&amp;quot;) # No issues

# Primary production absolute
BO_test(&amp;quot;BO2_ppmax_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_ppmax_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_ppmax_bdmin&amp;quot;) # No issues
BO_test(&amp;quot;BO2_ppmax_ss&amp;quot;) # No issues

# Primary production long-term
BO_test(&amp;quot;BO2_ppltmax_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_ppltmax_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_ppltmax_bdmin&amp;quot;) # No issues
BO_test(&amp;quot;BO2_ppltmax_ss&amp;quot;) # No issues

# Salinity absolute
BO_test(&amp;quot;BO2_salinityX_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_salinityX_bdmax&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Most pixels fail
BO_test(&amp;quot;BO2_salinityX_bdmax&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Most pixels fail
BO_test(&amp;quot;BO2_salinityX_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_salinityX_bdmean&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Most pixels fail
BO_test(&amp;quot;BO2_salinityX_bdmean&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Most pixels fail
BO_test(&amp;quot;BO2_salinityX_bdmin&amp;quot;) # No issues
BO_test(&amp;quot;BO2_salinityX_bdmin&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Most pixels fail
BO_test(&amp;quot;BO2_salinityX_bdmin&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Most pixels fail
BO_test(&amp;quot;BO2_salinityX_ss&amp;quot;) # No issues
BO_test(&amp;quot;BO2_salinityX_ss&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Almost all pixels fail
BO_test(&amp;quot;BO2_salinityX_ss&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Almost all pixels fail

# Salinity long-term
BO_test(&amp;quot;BO2_salinityltX_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_salinityltX_bdmax&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Global issues
BO_test(&amp;quot;BO2_salinityltX_bdmax&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Global issues
BO_test(&amp;quot;BO2_salinityltX_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_salinityltX_bdmean&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Global issues
BO_test(&amp;quot;BO2_salinityltX_bdmean&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Global issues
BO_test(&amp;quot;BO2_salinityltX_bdmin&amp;quot;) # No issues
BO_test(&amp;quot;BO2_salinityltX_bdmin&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Global issues
BO_test(&amp;quot;BO2_salinityltX_bdmin&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Global issues
BO_test(&amp;quot;BO2_salinityltX_ss&amp;quot;) # No issues
BO_test(&amp;quot;BO2_salinityltX_ss&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Almost all pixels fail
BO_test(&amp;quot;BO2_salinityltX_ss&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Almost all pixels fail

# Silicate absolute
BO_test(&amp;quot;BO2_silicatemax_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_silicatemax_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_silicatemax_bdmin&amp;quot;) # No issues
BO_test(&amp;quot;BO2_silicatemax_ss&amp;quot;) # No issues

# Silicate long-term
BO_test(&amp;quot;BO2_silicateltmax_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_silicateltmax_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_silicateltmax_bdmin&amp;quot;) # No issues
BO_test(&amp;quot;BO2_silicateltmax_ss&amp;quot;) # No issues

# Temperature absolute
BO_test(&amp;quot;BO2_tempX_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_tempX_bdmax&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Almost all pixels fail
BO_test(&amp;quot;BO2_tempX_bdmax&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Almost all pixels fail
BO_test(&amp;quot;BO2_tempX_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_tempX_bdmean&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Almost all pixels fail
BO_test(&amp;quot;BO2_tempX_bdmean&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Almost all pixels fail
BO_test(&amp;quot;BO2_tempX_bdmin&amp;quot;) # No issues
BO_test(&amp;quot;BO2_tempX_bdmin&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Almost all pixels fail
BO_test(&amp;quot;BO2_tempX_bdmin&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Almost all pixels fail
BO_test(&amp;quot;BO2_tempX_ss&amp;quot;) # No issues
BO_test(&amp;quot;BO2_tempX_ss&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # All pixels fail
BO_test(&amp;quot;BO2_tempX_ss&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # All pixels fail

# Temperature long-term
BO_test(&amp;quot;BO2_templtX_bdmax&amp;quot;) # No issues
BO_test(&amp;quot;BO2_templtX_bdmax&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Almost all pixels fail
BO_test(&amp;quot;BO2_templtX_bdmax&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Almost all pixels fail
BO_test(&amp;quot;BO2_templtX_bdmean&amp;quot;) # No issues
BO_test(&amp;quot;BO2_templtX_bdmean&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Almost all pixels fail
BO_test(&amp;quot;BO2_templtX_bdmean&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Almost all pixels fail
BO_test(&amp;quot;BO2_templtX_bdmin&amp;quot;) # No issues
BO_test(&amp;quot;BO2_templtX_bdmin&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # Almost all pixels fail
BO_test(&amp;quot;BO2_templtX_bdmin&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # Almost all pixels fail
BO_test(&amp;quot;BO2_templtX_ss&amp;quot;) # No issues
BO_test(&amp;quot;BO2_templtX_ss&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2050) # All but a few pixels fail
BO_test(&amp;quot;BO2_templtX_ss&amp;quot;, scenario = &amp;quot;RCP85&amp;quot;, year = 2100) # All but a few different pixels fail
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;discussion&#34;&gt;Discussion&lt;/h2&gt;

&lt;p&gt;This is not meant to be exhaustive, but does represent the majority of the data layers offered by Bio-Oracle. I had hypothesised that the three different depth options per pixel would have been related to the issues in the data assimilation but it does not appear to be the case. I&amp;rsquo;ve concluded this because whenever a depth layer has issues, those errors appear to be very similar across the three different depth layers. One consistent pattern we do see is if there are any errors, then every depth layer for that variable will also have errors. This also applies to absolute vs. long-term max/min layers. Errors in one means errors in all. Another consistent pattern in the error was that all of the future projections at all depths for absolute and long-term min/max values had errors in them. This begs the question of how it is that the future projection can have no errors, while the present day layers do not. How are these future projection layers calculated differently from the present day? Are they not based on the same data?&lt;/p&gt;

&lt;p&gt;Most of the layers that have issues are physical layers. It is my understanding that these layers would have been adapted from the GLORYS reanalysis product. Therefore the next logical step in understanding this issue would be to investigate the GLORYS data. But even if there were issues in the GLORYS product, which I doubt, it would not explain how the data layers here could have minimum values being reported as greater than the maximum values in the distribution. The only thing that makes any sense is that the data layers are created independently of each other. But why?&lt;/p&gt;

&lt;p&gt;Without being able to see the pipeline code myself all I can do is ponder, which isn&amp;rsquo;t terribly useful. So to wrap things up I&amp;rsquo;ll provide two tables; the layers with no issues, and those with issues. I would strongly recommend against using any data layers that did not pass the tests in this analysis until the curators of the Bio-Oracle data address these issues in a future release/version.&lt;/p&gt;

&lt;p&gt;Layers with no issues (fine for use):
- All of the older BO layers appear fine
- Carbon phytoplankton biomass absolute and long-term at all depths
- Chlorophyll absolute and long-term at all depths for present day projections only
- Dissolved oxygen absolute and long-term at all depths
- Ice cover absolute and long-term
- Ice thickness absolute and long-term for present day projections only
- Iron absolute and long-term for all depths
- Nitrate absolute and long-term for all depths
- Phosphate absolute and long-term for all depths
- Primary productivity absolute and long-term for all depths
- Salinity absolute and long-term at all depths for present day projections only
- Temperature absolute and long-term at all depths for present day projections only&lt;/p&gt;

&lt;p&gt;Problem layers (do not use):
- Chlorophyll future projections for absolutes and long-terms at all depths
- Current velocity absolutes and long-terms for all depths and all present and future projections
- Ice thickness absolute and long-term for future projections
- Light at bottom absolute and long-term for all depths
- Salinity absolute and long-term at all depths for future projections
- Temperature absolute and long-term at all depths for future projections&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>What and where? Predicting invasion hotspots in the Arctic marine realm</title>
      <link>https://theoceancode.netlify.app/publication/what_where/</link>
      <pubDate>Thu, 14 May 2020 00:00:00 +0200</pubDate>
      
      <guid>https://theoceancode.netlify.app/publication/what_where/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
